from __future__ import annotations

import argparse
import shutil
import subprocess
import sys
from datetime import datetime


def _build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog="backup",
        description="Create git backup commit and push to GitHub.",
    )
    parser.add_argument(
        "-m",
        "--message",
        default="",
        help="Commit message (default: autogenerated timestamp)",
    )
    parser.add_argument(
        "--remote",
        default="origin",
        help="Git remote name for push (default: origin)",
    )
    parser.add_argument(
        "--branch",
        default="",
        help="Git branch name (default: current branch)",
    )
    parser.add_argument(
        "--skip-push",
        action="store_true",
        help="Only create commit locally without push",
    )
    return parser


def _run_git(args: list[str]) -> subprocess.CompletedProcess[str]:
    return subprocess.run(
        ["git", *args],
        check=True,
        text=True,
        capture_output=True,
    )


def _ensure_git_repo() -> None:
    result = _run_git(["rev-parse", "--is-inside-work-tree"])
    if result.stdout.strip().lower() != "true":
        raise RuntimeError("Current directory is not a git repository")


def _get_remote_url(remote: str) -> str:
    result = _run_git(["remote", "get-url", remote])
    url = result.stdout.strip()
    if not url:
        raise RuntimeError(f"Git remote '{remote}' is empty")
    if "github.com" not in url.lower():
        raise RuntimeError(
            f"Remote '{remote}' is not GitHub: {url}. "
            "Set GitHub remote first (git remote set-url origin ...)."
        )
    return url


def _get_current_branch() -> str:
    result = _run_git(["rev-parse", "--abbrev-ref", "HEAD"])
    branch = result.stdout.strip()
    if not branch or branch == "HEAD":
        raise RuntimeError("Detached HEAD. Checkout a branch before backup.")
    return branch


def _working_tree_has_changes() -> bool:
    result = _run_git(["status", "--porcelain"])
    return bool(result.stdout.strip())


def _backup_commit_message(custom_message: str) -> str:
    if custom_message.strip():
        return custom_message.strip()
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    return f"backup: {timestamp}"


def main(argv: list[str] | None = None) -> int:
    parser = _build_parser()
    args = parser.parse_args(argv)

    if shutil.which("git") is None:
        print("Error: git is not found in PATH", file=sys.stderr)
        return 2

    try:
        _ensure_git_repo()
        remote_url = _get_remote_url(args.remote)
        branch = args.branch.strip() or _get_current_branch()

        _run_git(["add", "-A"])
        has_changes = _working_tree_has_changes()
        if has_changes:
            message = _backup_commit_message(args.message)
            _run_git(["commit", "-m", message])
            print(f"Commit created on '{branch}': {message}")
        else:
            print("No local changes to commit.")

        if args.skip_push:
            print("Push skipped (--skip-push).")
            return 0

        _run_git(["push", args.remote, branch])
        print(f"Backup pushed to {args.remote}/{branch} ({remote_url})")
        return 0
    except RuntimeError as exc:
        print(f"Error: {exc}", file=sys.stderr)
        return 2
    except subprocess.CalledProcessError as exc:
        stderr = (exc.stderr or "").strip()
        stdout = (exc.stdout or "").strip()
        details = stderr or stdout or str(exc)
        print(f"Error: git command failed: {details}", file=sys.stderr)
        return exc.returncode or 1


if __name__ == "__main__":
    raise SystemExit(main())
